package Acme::HeptaSymbolizer;
use strict;
use warnings;
use List::Util 'shuffle';
our $VERSION = '0.01';

{
    my @dict = (
        ['^','^'],
        ['(',')'],
        ['1','.','~','^','='],
        ['1','.','~','^',')','=','('],
        ['1','=','^','~','('],
        ['1','=',')','^','~'],
        ['(','.'],
        [')','.'],
        ['^','~','('],
        ['^','~',')'],
        ['1','.','=','('],
        ['1','.','=',')'],
        ['1','='],
        ['1','=',')','('],
        ['^','~','.'],
        ['^','~','(',')','.'],
        ['1','~','^',')','('],
        ['1','~','^'],
        ['(','.',')','='],
        ['=','.'],
        [')','='],
        ['(','='],
        ['1','.','~','^',')'],
        ['1','.','~','^','('],
        ['1',')'],
        ['1','('],
        ['^','~','.','=',')'],
        ['^','~','(','=','.'],
        ['^','~','(','=',')'],
        ['^','~','='],
        ['1','.','(',')'],
        ['1','.'],
        ['^','~'],
        ['^','~','(',')'],
        ['1','.','='],
        ['1','.','=',')','('],
        ['1','=','('],
        ['1','=',')'],
        ['^','~','(','.'],
        ['^','~','.',')'],
        ['('],
        [')'],
        ['1','.','~','^','(','='],
        ['1','.','~','^',')','='],
        ['1','=','^','~'],
        ['1','=',')','^','~','('],
        ['.'],
        ['(','.',')'],
        ['1','(',')'],
        ['1'],
        ['^','~','(','=','.',')'],
        ['^','~','.','='],
        ['^','~','=',')'],
        ['^','~','(','='],
        ['1','.',')'],
        ['1','.','('],
        ['1','~','^',')'],
        ['1','~','^','('],
        [')','=','.'],
        ['(','.','='],
        ['(','=',')'],
        ['='],
        ['1','.','~','^',')','('],
        ['1','.','~','^'],
        ['1','.','^','(',')'],
        ['1','.','^'],
        ['(','=',')','~'],
        ['~','='],
        [')','~','.','='],
        ['(','.','=','~'],
        ['1',')','^'],
        ['1','(','^'],
        ['1','.','~',')'],
        ['1','.','~','('],
        ['^','=',')'],
        ['^','=','('],
        ['^','.','(','=',')'],
        ['^','.','='],
        ['1','~','(',')'],
        ['1','~'],
        ['~','.'],
        ['(','.',')','~'],
        ['1','=','^'],
        ['1','=',')','^','('],
        ['1','.','=','^','('],
        ['1','.','=',')','^'],
        ['(','~'],
        [')','~'],
        ['^','.','('],
        ['^','.',')'],
        ['1','=','~','('],
        ['1','=',')','~'],
        ['1','.','~','='],
        ['1','.','~','=','(',')'],
        ['^'],
        ['^','(',')'],
        ['1','.','~',')','('],
        ['1','.','~'],
        ['^','=','(',')'],
        ['^','='],
        ['^','.','=',')'],
        ['^','.','(','='],
        ['1','~',')'],
        ['1','~','('],
        ['1','.','^',')'],
        ['1','.','^','('],
        [')','~','='],
        ['(','=','~'],
        ['(','.',')','~','='],
        ['~','=','.'],
        ['1','(','^',')'],
        ['1','^'],
        ['^','.'],
        ['^','.','(',')'],
        ['1','=','~'],
        ['1','=',')','~','('],
        ['1','.','~','=','('],
        ['1','.','~','=',')'],
        ['^','('],
        ['^',')'],
        ['(','.','~'],
        [')','~','.'],
        ['1','=','^','('],
        ['1','=',')','^'],
        ['1','.','=','^'],
        ['1','.','=',')','(','^'],
        ['~'],
        ['(',')','~'],
    );

    sub symbolize {
        my ($str, $quote) = @_;

        my @results;
        for my $char (unpack 'C*', $str) {
            my $reverse = $char >= 128 ? 1 : 0;
            $char = 255 - $char if $reverse;
            my $result = ($reverse ? '~' : '') . "(${quote}" . join("${quote}^${quote}", shuffle @{ $dict[$char] }) . "${quote})";
            $result =~ s/${quote}1${quote}/(${quote}${quote}==${quote}${quote}).${quote}${quote}/g;
            push @results, $result;
        }

        return join '.', @results;
    }
}

sub import {
    my ($pkg, $arg) = @_;

    my @caller = caller;
    return if $caller[0] eq $pkg;

    my $quote = defined $arg && $arg eq 'qq' ? q/"/ : q/'/;
    open 0 or print "Can't symbolize '$0'\n" and exit;
    my $code = join '', <0>;

    if ($code =~ /^[\(\)\.\^\~\=${quote}]+$/) {
        do {
            no warnings 'numeric';
            eval $code;
        };
    }
    else {
        $code =~ s/([\"\$\@\\\{\}])/\\$1/g;
        my $symbolized = "${quote}${quote}=~(" . symbolize(qq/(?{eval"$code"})/, $quote) . ')';
        open 0, ">$0" or print "Can't symbolize '$0'\n" and exit;
        {
            no strict 'refs';
            print {0} $symbolized;
        }
    }
    exit;
}

1;
__END__

=head1 NAME

Acme::HeptaSymbolizer -

=head1 SYNOPSIS

  use Acme::HeptaSymbolizer;

=head1 DESCRIPTION

Acme::HeptaSymbolizer is

=head1 AUTHOR

sugyan E<lt>sugi1982@gmail.comE<gt>

=head1 SEE ALSO

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
